<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IT on 安怡的博客</title>
    <link>https://anyicomplex.github.io/categories/it/</link>
    <description>Recent content in IT on 安怡的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>2021 © anyicomplex</copyright>
    <lastBuildDate>Mon, 28 Feb 2022 15:45:19 -0500</lastBuildDate><atom:link href="https://anyicomplex.github.io/categories/it/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>对C/C&#43;&#43;程序体积的极致裁剪</title>
      <link>https://anyicomplex.github.io/posts/ultimate-trimming-for-c-c&#43;&#43;-programs-size/</link>
      <pubDate>Mon, 28 Feb 2022 15:45:19 -0500</pubDate>
      
      <guid>https://anyicomplex.github.io/posts/ultimate-trimming-for-c-c&#43;&#43;-programs-size/</guid>
      <description>起因 程序的分发一直是困扰各大程序员的老大难问题，尤其是在小程序的分发上。
如果你只是写了个功能很有限的小程序，却要拖家带口几十M的运行时，我相信，用户一定会觉得不值得的。
如果你以“现在硬盘白菜价了”或者“都5G时代了，网络带宽早不值钱了”这种理由来反驳我，那么请立即关闭我的这篇博文，因为这不是写给你看的。
方法 1.动态调用运行时 只要目标设备包含了程序所需的运行时和依赖库，就可以通过动态调用的方式缩小体积。
*nix 这在*nix平台下不是问题，因为必定包含可用的C/C++运行时，又在程序库方面做到了模块化，在使用包管理器的情况下只需要指定对应的依赖，否则就只能让用户手动去安装了。
如果不想麻烦用户，又不使用包管理器，那么就只有减少依赖，只使用目标平台必定包含的库了。
Windows Windows并没有做到程序库方面的模块化，除了一些基本的C/C++运行时库，所以只有减少依赖一种方法。
但如果要兼容老版本系统的话，必定包含的库就极其有限，甚至连部分基本的C/C++运行时库也不是必定包含，这时候要么麻烦用户，要么就只能用老版本的运行时库了。
 使用Visual C++ 6.0
用VC6.0编译出的C/C++程序，运行时就只有msvcrt.dll这一个库，而这个库从Windows2000起就必定包含在系统中了。 使用MinGW并且不使用C++
如果不想用VC6.0这种停止维护多年的编译器，又想保证兼容性和裁剪体积，那么使用MinGW并且不使用C++也是一种不错的方案。
msvcrt版本的MinGW编译出的C语言程序和VC6.0一样，运行时只有msvcrt.dll一个库（C++程序则需要带libstdc++或libc++这种对Windows而言是第三方的C++运行时）。  2.调整编译器参数 我想这个不用我多说，指定编译器优化代码和不插入调试信息等属于基本功。
3.使用压缩壳 UPX、ASPack等压缩壳可以压缩程序体积，但会让程序占用额外的内存（因为要把压缩后的程序解压到内存里）和拖慢启动时间（虽然也不至于拖慢太多）。
对于这种方法，我的建议是：按自己的需求来。
总结 写完之后再想想，实际上现在真没必要这么抠&amp;hellip;&amp;hellip;这年头5M以下的小工具基本都在用户的可接受范围内吧，而未经压缩的20M～30M的可执行文件压缩一下也基本能到5M以下吧。</description>
    </item>
    
    <item>
      <title>在Linux下编写和编译win32程序</title>
      <link>https://anyicomplex.github.io/posts/writing-and-compiling-win32-programs-under-linux/</link>
      <pubDate>Mon, 28 Feb 2022 14:24:36 -0500</pubDate>
      
      <guid>https://anyicomplex.github.io/posts/writing-and-compiling-win32-programs-under-linux/</guid>
      <description>本文所说的“win32”是中国大陆程序员圈子对“winapi”的俗称，不是特指32位“winapi”（别说64位了，自从32位winapi出现，对早期16位的winapi我们也这么叫）。
可行性 得益于MinGW（Minimalist GNU for Windows）这个项目，只要不涉及到比较高层次的封装（MFC、WPF等），是完全可行的。（实际上也有各种奇技淫巧使用MFC和WPF，但我不建议那么做，如果真要那么做，在Wine下使用MSVC也许会更好一点）
当然，因为原MinGW项目不支持64位，我这里说的MinGW都是指MinGW-w64（和原MinGW不是同一个项目）。
安装 一般而言，主流Linux发行版的软件源都会包含MinGW相关的软件包，当然，如果没有，或者需要官方源已有软件包以外的功能，也可以自己去官网下载源码和编译好的可执行文件什么的～详情请参阅 https://www.mingw-w64.org/downloads/
我现在使用的操作系统是Fedora 35，是参考这篇官方文档装的。
除非官方文档太烂，否则还是建议跟着官方文档来。
使用 “MinGW不生产工具链，只是GNU工具链的搬运工。”
除了命令的名称不同以外，其他都和GNU工具链一样，举个例子，编译64位C语言程序，把“gcc”换成“x86_64-w64-mingw32-gcc”即可。
除编译器以外，MinGW里还有不少其他的工具，用于和编译器配套使用（Linux原装的GNU构建工具无法和MinGW编译器配套使用，或者需要额外配置）。配置IDE或文本编辑器的时候，一定要把全套工具都换成MinGW的！
至于具体有哪些工具，我这里就不一一列举了，安装好后可以在“/usr/bin”目录下搜索“mingw”。
头文件和库文件等可以在“/usr/x86_64-w64-mingw32”和“/usr/i686-w64-mingw32”目录下找到。
总结 不使用MFC的win32开发太痛苦了&amp;hellip;&amp;hellip;</description>
    </item>
    
    <item>
      <title>Xlib编程注意事项 1</title>
      <link>https://anyicomplex.github.io/posts/xlib-programming-notes-1/</link>
      <pubDate>Sun, 20 Feb 2022 11:02:21 -0500</pubDate>
      
      <guid>https://anyicomplex.github.io/posts/xlib-programming-notes-1/</guid>
      <description> 谨慎使用XGrabPointer，使用前一定要做好强制退出程序的准备（今天我被坑到了，还不止一次QAQ）  </description>
    </item>
    
    <item>
      <title>给C&#43;&#43;初学者的一些建议</title>
      <link>https://anyicomplex.github.io/posts/some-advice-for-cpp-beginners/</link>
      <pubDate>Sat, 19 Feb 2022 09:33:19 -0500</pubDate>
      
      <guid>https://anyicomplex.github.io/posts/some-advice-for-cpp-beginners/</guid>
      <description>基础  在学C++之前先学C语言，掌握堆栈等基本概念，并能够熟练使用指针和宏。 新版本的特性先不要学，哪怕只是用于学习而非生产，也建议只使用长期支持的稳定版本。  应用  先别急着深入学习模板等C++高级特性，对新手而言，把C++当作“带类的C”是最稳妥的使用方法。 STL里有的东西就不要去找第三方库了（除非这个库真的比STL的那部分好并且长期有人维护）。 Boost可以用，但也仅仅只是可以用，因为坑太多。对新手而言，很多时候难以分辨是自己写的程序的问题还是编译器或Boost的问题（STL就好得多，毕竟Boost是STL的上游）。  编译器  Windows下不建议使用MSVC以外的编译器，否则坑很多。 Linux下Clang和GCC均可，但我一般建议使用GCC。 macOS下建议Clang。  IDE VSCode不是IDE，是文本编辑器，所以不在这个推荐列表内（当然，我推荐它，因为我没钱买IDEA Ultimate却需要写JNI，它帮了大忙:D）。
 Qt开发者可以直接用Qt的工具链。 Eclipse和Code::Blocks老用户可以继续用，这两个IDE不是不好，是难以上手，当然对老用户而言没什么问题。 Windows下建议Visual Studio和MSVC配合使用，如果用惯了JetBrains系的IDE也可以用CLion，其他不推荐。 Linux下，建议CLion，KDE桌面也可以使用KDevelop，但其他桌面不建议（因为KDevelop的依赖会带一大堆KDE的软件包，这也是KDE应用的通病，耦合度太高），GNOME桌面也可以使用GNOME Builder（这个其他桌面用也没什么问题），其他不推荐。 macOS下建议XCode，觉得不好用就换AppCode/CLion，其他没有更好的了。  </description>
    </item>
    
    <item>
      <title>用C语言的风格写Java程序</title>
      <link>https://anyicomplex.github.io/posts/writing-c-style-java-programs/</link>
      <pubDate>Sun, 13 Feb 2022 08:52:46 -0500</pubDate>
      
      <guid>https://anyicomplex.github.io/posts/writing-c-style-java-programs/</guid>
      <description>可行性 都说Java是纯面向对象的编程语言，那么能不能在Java中写面向过程风格的代码呢？
Java中虽然没有指针，但有引用，所以答案显然是可以的。
风格的区别 先来看两段伪代码：
C语言风格 struct Foo foo; change_foo_value(&amp;amp;foo, 0); Java风格 Foo foo = new Foo(); foo.changeValue(0); 这同样也能体现面向对象和面向过程两种设计模式的区别。
两种风格都不错，是吧？
实际应用中的问题 如果某个方法需要返回两种值，该怎么写程序？
设需求为：用程序启动Shell脚本，获取脚本的返回值和输出。
C语言风格 int exec_script(char *script_path, char **output) { int exit_code; // Business logic 	... return exit_code; } Java风格 class Result { public final int exitCode; public final String output; public Result(int exitCode, String output) { this.exitCode = exitCode; this.output = output; } } Result execScript(String scriptPath) { int exitCode; StringBuilder outputBuffer = new StringBuilder(); // Business logic 	.</description>
    </item>
    
    <item>
      <title>使用Linux的理由</title>
      <link>https://anyicomplex.github.io/posts/reasons-to-use-linux/</link>
      <pubDate>Wed, 08 Dec 2021 08:17:44 -0500</pubDate>
      
      <guid>https://anyicomplex.github.io/posts/reasons-to-use-linux/</guid>
      <description>本文仅代表个人观点，欢迎留言讨论。
1.轻量级 （以x86_64操作系统为例，针对日常使用，因此注重轻量级精简太多功能的发行版不算在内）    操作系统 最低CPU需求 最低内存需求 最低储存需求     Windows 11 1 GHz * 2 4 GB 64 GB   Windows 10 1 GHz 2 GB 20 GB   Windows 7 1 GHz 2 GB 20 GB   Fedora 35 (GNOME) 2 GHz 2 GB 15 GB   Debian 11 (GNOME) 1 GHz 1 GB 10 GB    数据均来自官网</description>
    </item>
    
    <item>
      <title>写给想用Java开发游戏的人的话</title>
      <link>https://anyicomplex.github.io/posts/words-for-those-want-to-develop-game-in-java/</link>
      <pubDate>Thu, 07 Oct 2021 02:23:11 -0500</pubDate>
      
      <guid>https://anyicomplex.github.io/posts/words-for-those-want-to-develop-game-in-java/</guid>
      <description>本文仅代表个人观点，欢迎留言讨论。
Java适合开发游戏吗？ 我的答案是：不适合。
如果你不追求开源，Unity和GameMaker这类成熟的商业解决方案显然是最好的选择。
如果你追求开源，多如牛毛的开源游戏引擎（绝大多数是用C/C++编写的）总有一款是你的菜。（这里不列举，请自行到各大开源平台搜索）
如果现有游戏引擎都不能使你满意，你可以尝试自己编写——但是，我不推荐使用Java，准确地说，不推荐使用任何一门委托型语言，甚至带GC的非委托型语言我都不推荐。低延迟的即时交互对于电子游戏而言是至关重要的，在这方面，委托型语言先天不足。（Unity虽然用C#做开发，但底层还是C/C++，并且针对C#代码进行了AOT编译，以提升性能）
如果你没有非用Java不可的理由，就请打消用Java开发游戏的念头。
如果我非用Java不可呢？ Java的生态很庞大，事实上，相对成熟的解决方案还是有的。
 libGDX：侧重于2D，支持平台：Windows/Linux/Mac/Android/iOS/HTML5 jMonkeyEngine：纯3D，支持平台：Windows/Linux/Mac/Android/iOS/HTML5  我认为相对完善的Java游戏引擎只有这两个，其他都不够成熟。
尝试使用libGDX开发3D游戏不是个明智的选择，而用jMonkeyEngine开发2D游戏是一件相当不理智的事。
Java能开发像王者荣耀那样的大型游戏吗？ 能。
Java的缺陷从来就不在大型化上，不然也不会有那么多服务器跑SpringBoot一类用Java编写的Web后端框架了。
大名鼎鼎的PokeMMO就是用libGDX开发的。
用Java开发游戏需要注意些什么？ 在桌面平台，几乎不可能让玩家们专门为你的游戏去安装JRE。
因此，必须在打包和精简JRE上下足功夫，提供不同桌面平台对应的安装包，保证开箱即用的用户体验。
JRE的体积曾是个问题，但好在如今对游戏文件的体积要求也没有那么高了。
至于其他问题，那不属于Java的范畴，而是所有游戏开发者都需要面对的问题。
GraalVM的native-image技术可以用于Java游戏开发吗？ 理论上可行，但我不推荐。
除非你对缩小游戏文件体积有较高的要求，否则这么做只会让你在损失很多Java特性和第三方库的同时面临很多不必要的麻烦。
把Java字节码完全AOT成本地可执行文件可以减少启动时间和系统资源占用，但这都不是游戏开发的重点。
如果你很看重游戏文件体积、系统资源占用和启动时间，那么还是趁早打消用Java开发游戏的念头。</description>
    </item>
    
  </channel>
</rss>
